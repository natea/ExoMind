# Integration Architecture Assessment

**Date**: October 19, 2025
**Reviewer**: Backend API Developer Agent
**Scope**: Integration documentation for 5 external services (Todoist, Gmail, Keep, Bookmarks, Telegram)

---

## Executive Summary

The integration documentation demonstrates **strong architectural thinking** with comprehensive coverage of security, error handling, and data flow patterns. However, there are **significant gaps between documentation and implementation**, along with **critical security concerns** that must be addressed before production deployment.

**Overall Assessment**: üü° **YELLOW** - Solid foundation with critical gaps

### Key Findings

| Category | Status | Priority |
|----------|--------|----------|
| **Security** | üî¥ Critical Issues | P0 |
| **Completeness** | üü° Partial Coverage | P1 |
| **Error Handling** | üü¢ Well Documented | P2 |
| **Practicality** | üü° Implementation Gaps | P1 |
| **API Compatibility** | üü¢ Correct Approaches | P2 |

---

## 1. Security Assessment

### üî¥ **CRITICAL: Exposed Credentials in .mcp.json**

**Finding**: OAuth credentials are **hardcoded and committed** to version control:

```json
{
  "google-workspace": {
    "env": {
      "GOOGLE_OAUTH_CLIENT_ID": "[REDACTED-CLIENT-ID].apps.googleusercontent.com",
      "GOOGLE_OAUTH_CLIENT_SECRET": "[REDACTED-CLIENT-SECRET]",
      "USER_GOOGLE_EMAIL": "[REDACTED-EMAIL]",
      "OAUTHLIB_INSECURE_TRANSPORT": "1"
    }
  }
}
```

**Note**: Actual credentials have been redacted for security. The exposed values found during audit have been revoked.

**Impact**:
- Anyone with access to the repository can use these credentials
- OAuth client secret is publicly exposed
- Violates OAuth 2.0 security best practices
- Enables unauthorized access to user's Google Workspace

**Immediate Actions Required**:
1. ‚úÖ **REVOKE** the exposed OAuth credentials in Google Cloud Console
2. ‚úÖ **REMOVE** credentials from `.mcp.json` immediately
3. ‚úÖ **ADD** `.mcp.json` to `.gitignore`
4. ‚úÖ **ROTATE** all potentially compromised credentials
5. ‚úÖ **IMPLEMENT** environment-based credential loading

**Recommended Fix**:

```json
// .mcp.json (template, not committed)
{
  "google-workspace": {
    "env": {
      "GOOGLE_OAUTH_CLIENT_ID": "${GOOGLE_OAUTH_CLIENT_ID}",
      "GOOGLE_OAUTH_CLIENT_SECRET": "${GOOGLE_OAUTH_CLIENT_SECRET}",
      "USER_GOOGLE_EMAIL": "${USER_GOOGLE_EMAIL}"
    }
  }
}

// .env.local (in .gitignore)
GOOGLE_OAUTH_CLIENT_ID=your_client_id
GOOGLE_OAUTH_CLIENT_SECRET=your_secret
USER_GOOGLE_EMAIL=your_email
```

### üü° **Security Issues in Documentation**

#### 1. Token Storage Weaknesses

**Documentation Claims**:
> "Store tokens in encrypted keychain (macOS Keychain, Linux Secret Service)"

**Reality**:
- Gmail script stores tokens in plaintext `token.json` file
- Todoist uses environment variables (better, but not encrypted at rest)
- No keychain integration implemented

**Recommendation**:
```typescript
// Implement proper keychain storage
import keytar from 'keytar';

async function storeToken(service: string, token: string): Promise<void> {
  await keytar.setPassword('life-os', service, token);
}

async function retrieveToken(service: string): Promise<string | null> {
  return await keytar.getPassword('life-os', service);
}
```

#### 2. OAuth Flow Implementation Gaps

**Documentation**: Comprehensive OAuth 2.0 flow with refresh tokens
**Implementation**: Basic local auth without:
- Token expiration handling
- Automatic refresh
- Error recovery
- Multi-user support

#### 3. Insecure Transport Mode

**Critical Issue**:
```json
"OAUTHLIB_INSECURE_TRANSPORT": "1"
```

This **disables HTTPS requirement** for OAuth callbacks, making the system vulnerable to:
- Man-in-the-middle attacks
- Token interception
- Credential theft

**Required**: Remove this flag and use HTTPS even in development (via ngrok/localhost tunneling)

---

## 2. Completeness Assessment

### ‚úÖ **Fully Covered Services**

#### Todoist (90% Complete)
- ‚úÖ Bidirectional sync implemented
- ‚úÖ API token authentication
- ‚úÖ YAML-based local storage
- ‚úÖ Import/export functionality
- ‚úÖ Rate limiting (500ms delays)
- ‚ö†Ô∏è Missing: Webhook support for real-time updates
- ‚ö†Ô∏è Missing: Conflict resolution (only last-write-wins)
- ‚ö†Ô∏è Missing: OAuth 2.0 support (only API tokens)

#### Gmail (60% Complete)
- ‚úÖ OAuth 2.0 authentication
- ‚úÖ Message listing
- ‚úÖ Google Workspace MCP integration available
- ‚ùå Missing: Email processing pipeline (documented but not implemented)
- ‚ùå Missing: AI-based action extraction
- ‚ùå Missing: Label management
- ‚ùå Missing: Push notification setup (Pub/Sub)
- ‚ùå Missing: Email sending capability

### üü° **Partially Covered Services**

#### Google Keep (0% Implementation)
**Status**: Documented only, zero implementation

**Documentation Claims**:
- Chrome extension approach
- HMAC signature verification
- Webhook integration
- Google Tasks API alternative

**Reality**: No code exists for any of these approaches

**Blocker**: No official Keep API means this integration requires **significant custom development**:
1. Build Chrome extension (estimated 40-60 hours)
2. Implement webhook server (8-16 hours)
3. Create authentication flow (8-12 hours)
4. Test across browsers (8-16 hours)

**Alternative Recommendation**: Use **Google Tasks API** (official, supported) instead:
```typescript
import { google } from 'googleapis';

const tasks = google.tasks({
  version: 'v1',
  auth: oauth2Client
});

// List task lists
const taskLists = await tasks.tasklists.list();

// Add task
await tasks.tasks.insert({
  tasklist: 'primary',
  requestBody: {
    title: 'Task from Life-OS',
    notes: 'Captured note content'
  }
});
```

#### Chrome Bookmarks (0% Implementation)
**Status**: Documented only, no implementation

**Required Work**:
1. Chrome extension development (24-40 hours)
2. Bookmark sync service (16-24 hours)
3. API endpoints for webhook (8-12 hours)
4. Search and categorization (16-24 hours)

**Estimated Total**: 64-100 hours of development

#### Telegram (0% Implementation)
**Status**: Documented only, no bot created

**Required Work**:
1. Create bot via BotFather (5 minutes)
2. Implement webhook handler (8-16 hours)
3. Command parser (8-12 hours)
4. Integration with Claude Skills (16-24 hours)
5. Interactive keyboard implementation (8-12 hours)

**Estimated Total**: 40-64 hours of development

---

## 3. Error Handling Assessment

### ‚úÖ **Well Documented**

The documentation provides **excellent error handling patterns**:

```typescript
class TodoistErrorHandler {
  async handle(error: TodoistError): Promise<void> {
    switch (error.status) {
      case 401: await this.refreshToken(); break;
      case 429: await this.backoff(error.retryAfter); break;
      case 503: await this.queueForRetry(error.request); break;
      default: await this.logAndNotify(error);
    }
  }
}
```

**Strengths**:
- Comprehensive HTTP status code handling
- Exponential backoff strategies
- Rate limit awareness
- Service-specific error handlers
- Graceful degradation patterns

### üü° **Implementation Gaps**

**Todoist Implementation**:
```typescript
// Current implementation (todoist.ts, lines 146-157)
catch (taskError: any) {
  console.error(`Error processing task "${task.content}":`, taskError.message);
  if (taskError.httpStatusCode === 503) {
    console.log("Service temporarily unavailable. Waiting 5 seconds...");
    await sleep(5000);
  }
  continue;
}
```

**Issues**:
- Only handles 503 errors
- No token refresh logic
- No retry queue
- No user notification
- Continues silently on failure

**Recommended Enhancement**:
```typescript
class TodoistErrorHandler {
  private retryQueue: Array<{ task: MemoryTask; retries: number }> = [];
  private maxRetries = 3;

  async handleError(error: TodoistError, task: MemoryTask): Promise<void> {
    switch (error.httpStatusCode) {
      case 401:
        await this.refreshApiToken();
        await this.queueRetry(task);
        break;
      case 429:
        const retryAfter = parseInt(error.headers?.['retry-after'] || '60');
        await this.exponentialBackoff(retryAfter);
        await this.queueRetry(task);
        break;
      case 503:
        await this.exponentialBackoff(5);
        await this.queueRetry(task);
        break;
      default:
        await this.logError(error, task);
        await this.notifyUser(error, task);
    }
  }

  private async queueRetry(task: MemoryTask): Promise<void> {
    const existing = this.retryQueue.find(r => r.task === task);
    if (existing) {
      existing.retries++;
      if (existing.retries >= this.maxRetries) {
        await this.moveToDeadLetterQueue(task);
        this.retryQueue = this.retryQueue.filter(r => r.task !== task);
      }
    } else {
      this.retryQueue.push({ task, retries: 1 });
    }
  }
}
```

---

## 4. Practicality & Implementation Assessment

### üü¢ **Implementable Patterns**

The following documented patterns are **practical and correct**:

1. **Event Bus Architecture** (lines 858-898)
   - Scalable pub/sub pattern
   - Loose coupling between services
   - Easy to add new integrations

2. **Credential Vault** (lines 900-926)
   - Proper encryption approach
   - System keychain integration
   - Secure storage patterns

3. **Sync State Machine** (lines 475-491)
   - Clear state transitions
   - Handles retry logic
   - Manual intervention path

4. **Batch Processing** (lines 626-646)
   - Efficient API usage
   - Rate limit compliance
   - Queue-based approach

### üü° **Implementation Blockers**

#### Missing Infrastructure Components

**Documented**:
```yaml
# docker-compose.yml (lines 1019-1042)
services:
  life-os:
    build: .
    ports: ["3000:3000"]
  webhook-relay:
    image: ngrok/ngrok
```

**Reality**: No Docker configuration exists

**Required Infrastructure**:
1. PostgreSQL database (for sync state)
2. Redis cache (for rate limiting)
3. Message queue (RabbitMQ/Redis)
4. Webhook endpoints (Express/Fastify server)
5. Background job processor

**Estimated Setup Time**: 16-24 hours

#### Deployment Architecture Gap

**Documentation** shows production-ready architecture with:
- Load balancer
- API gateway
- Multiple services
- Message queue
- Redis cache
- PostgreSQL

**Reality**: No deployment configuration exists

**Required**:
1. Infrastructure as Code (Terraform/CloudFormation)
2. Container orchestration (Kubernetes/ECS)
3. Monitoring setup (Prometheus/Grafana)
4. CI/CD pipeline
5. Environment management

**Estimated Time**: 80-120 hours

---

## 5. API Compatibility Assessment

### ‚úÖ **Correct API Usage**

#### Todoist API ‚úÖ
```typescript
// Correct usage of official SDK
const api = new TodoistApi(process.env.TODOIST_API_TOKEN);
const tasks = await api.getTasks();
await api.addTask(updateData);
```

**Compatibility**: 100%
- Uses official TypeScript SDK
- Follows API v2 specifications
- Proper rate limiting implemented

#### Gmail API ‚úÖ
```typescript
// Correct OAuth and API usage
const gmail = google.gmail({ version: 'v1', auth });
const response = await gmail.users.messages.list({
  userId: 'me',
  maxResults: 100
});
```

**Compatibility**: 100%
- Uses official Google APIs Node.js client
- Correct OAuth 2.0 scopes
- Proper v1 endpoint usage

#### Google Workspace MCP ‚úÖ

**Available in .mcp.json**:
```json
{
  "google-workspace": {
    "command": "uvx",
    "args": ["workspace-mcp"]
  }
}
```

**Functionality**: The MCP server provides comprehensive tools:
- `search_gmail_messages` - Search with Gmail query syntax
- `get_gmail_message_content` - Retrieve full email content
- `send_gmail_message` - Send emails with HTML support
- `modify_gmail_message_labels` - Label management
- Calendar, Drive, Docs, Sheets integration

**Assessment**: This is a **better alternative** to the documented direct API approach because:
1. Pre-built authentication handling
2. Comprehensive tool coverage
3. Active maintenance
4. No custom OAuth implementation needed

### üî¥ **API Compatibility Issues**

#### Google Keep - No Official API ‚ùå

**Documentation Claim**: "Unofficial Python Library (Keep API)"

**Reality**:
- No official Google Keep API exists
- Unofficial libraries are **unstable and unsupported**
- Violates Google's Terms of Service
- Can break at any time

**Risk Level**: üî¥ HIGH

**Recommendation**:
1. **Remove Keep integration** from roadmap OR
2. **Replace with Google Tasks API** (official alternative)

#### Chrome Bookmarks - Extension Required ‚ö†Ô∏è

**Documentation Approach**: Chrome extension with webhook

**Challenges**:
1. Requires Chrome Web Store submission (review process 1-2 weeks)
2. Extension permissions require user consent
3. Cross-browser compatibility issues
4. Manifest V3 migration required (V2 deprecated)

**Alternative**: Export/import bookmark HTML files (simpler, no extension needed)

---

## Missing Integration Patterns

### 1. **Webhook Security Not Implemented**

**Documentation** (lines 686-704):
```typescript
// Verify webhook secret
const token = req.headers.get('X-Telegram-Bot-Api-Secret-Token');
if (token !== TELEGRAM_WEBHOOK_SECRET) {
  throw new SecurityError('Invalid webhook secret');
}
```

**Missing**:
- No webhook server implementation
- No signature verification
- No HMAC validation
- No replay attack prevention

**Required Implementation**:
```typescript
import crypto from 'crypto';

class WebhookSecurityManager {
  private secrets: Map<string, string> = new Map();

  async verifySignature(
    payload: string,
    signature: string,
    service: string
  ): Promise<boolean> {
    const secret = this.secrets.get(service);
    if (!secret) throw new Error(`No secret for service: ${service}`);

    const hmac = crypto.createHmac('sha256', secret);
    const expectedSignature = hmac.update(payload).digest('hex');

    // Constant-time comparison to prevent timing attacks
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  }

  async verifyTimestamp(timestamp: number, maxAge: number = 300): Promise<boolean> {
    const now = Date.now() / 1000;
    return Math.abs(now - timestamp) <= maxAge;
  }
}
```

### 2. **No Circuit Breaker Pattern**

**Documentation** mentions circuit breakers (lines 502-521) but no implementation exists.

**Required**:
```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailureTime: number = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > 60000) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= 5) {
      this.state = 'OPEN';
    }
  }
}
```

### 3. **No Conflict Resolution Strategy**

**Documentation** (lines 59-78) describes conflict resolution but implementation only does "last-write-wins":

```typescript
// todoist.ts - No conflict detection
if (task.todoist_id) {
  await api.updateTask(task.todoist_id, updateData); // Always overwrites
}
```

**Required**:
```typescript
interface ConflictResolver {
  async resolve(local: Task, remote: Task): Promise<Task> {
    // Compare timestamps
    if (local.updated_at > remote.updated_at) {
      return local;
    } else if (remote.updated_at > local.updated_at) {
      return remote;
    }

    // Same timestamp - merge or prompt user
    if (this.canAutoMerge(local, remote)) {
      return this.mergeChanges(local, remote);
    } else {
      return await this.promptUser(local, remote);
    }
  }

  private canAutoMerge(local: Task, remote: Task): boolean {
    // Check if changes are in different fields
    const localChanges = this.getChangedFields(local);
    const remoteChanges = this.getChangedFields(remote);

    return !localChanges.some(field => remoteChanges.includes(field));
  }
}
```

### 4. **Missing Rate Limiting**

**Documentation** shows rate limiting but only Todoist implements basic delays:

```typescript
// Current implementation
await sleep(500); // Simple delay
```

**Required Token Bucket Algorithm**:
```typescript
class RateLimiter {
  private tokens: number;
  private lastRefill: number;
  private readonly maxTokens: number;
  private readonly refillRate: number; // tokens per second

  constructor(maxTokens: number, refillRate: number) {
    this.maxTokens = maxTokens;
    this.refillRate = refillRate;
    this.tokens = maxTokens;
    this.lastRefill = Date.now();
  }

  async acquire(count: number = 1): Promise<void> {
    this.refill();

    if (this.tokens >= count) {
      this.tokens -= count;
      return;
    }

    // Wait until tokens available
    const waitTime = ((count - this.tokens) / this.refillRate) * 1000;
    await new Promise(resolve => setTimeout(resolve, waitTime));
    this.refill();
    this.tokens -= count;
  }

  private refill(): void {
    const now = Date.now();
    const timePassed = (now - this.lastRefill) / 1000;
    const tokensToAdd = timePassed * this.refillRate;

    this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }
}

// Usage
const todoistLimiter = new RateLimiter(100, 2); // 100 tokens, 2/sec
await todoistLimiter.acquire();
await api.addTask(data);
```

---

## Specific Improvements Needed

### Priority 0 (Critical - Security)

1. **Revoke and Rotate Exposed Credentials**
   - Action: Immediately revoke OAuth credentials in `.mcp.json`
   - Timeline: 1 hour
   - Owner: DevOps/Security team

2. **Implement Credential Vault**
   - Replace file-based token storage with system keychain
   - Use `keytar` library for cross-platform support
   - Timeline: 8-16 hours
   - Files to modify:
     - `modules/life-os/scripts/gmail.ts`
     - `modules/life-os/scripts/todoist.ts`

3. **Remove Insecure Transport Mode**
   - Remove `OAUTHLIB_INSECURE_TRANSPORT` flag
   - Implement HTTPS for OAuth callbacks (use ngrok in dev)
   - Timeline: 4-8 hours

### Priority 1 (High - Core Functionality)

4. **Implement Gmail Email Processing**
   - AI-based action extraction from emails
   - Automatic task creation
   - Label management
   - Timeline: 24-40 hours
   - Dependencies: Google Workspace MCP already available

5. **Complete Todoist Sync**
   - Webhook support for real-time updates
   - Proper conflict resolution
   - OAuth 2.0 support
   - Timeline: 16-24 hours

6. **Replace Keep with Google Tasks**
   - Remove Keep integration documentation
   - Implement Google Tasks API
   - Update user-facing documentation
   - Timeline: 16-24 hours

7. **Implement Webhook Server**
   - Express/Fastify server
   - HMAC signature verification
   - Rate limiting
   - Timeline: 16-24 hours

### Priority 2 (Medium - Infrastructure)

8. **Create Unified Error Handling**
   - Implement service-specific error handlers
   - Add retry queue
   - Dead letter queue for failed operations
   - Timeline: 16-24 hours

9. **Add Circuit Breaker Pattern**
   - Implement circuit breaker for each external service
   - Configurable thresholds
   - Monitoring/alerting integration
   - Timeline: 8-16 hours

10. **Implement Rate Limiting**
    - Token bucket algorithm
    - Per-service configuration
    - Redis-backed for distributed systems
    - Timeline: 8-16 hours

### Priority 3 (Low - Nice-to-Have)

11. **Chrome Bookmarks Integration**
    - Build Chrome extension
    - Implement webhook integration
    - Add search/categorization
    - Timeline: 64-100 hours

12. **Telegram Bot**
    - Create bot via BotFather
    - Implement command parser
    - Interactive keyboards
    - Timeline: 40-64 hours

13. **Monitoring & Observability**
    - Prometheus metrics
    - Grafana dashboards
    - Alert configuration
    - Timeline: 24-40 hours

---

## Recommended Architecture Changes

### 1. Use Google Workspace MCP Instead of Direct API

**Current Approach**:
```typescript
// Direct Gmail API usage
const gmail = google.gmail({ version: 'v1', auth });
const messages = await gmail.users.messages.list({ userId: 'me' });
```

**Recommended Approach**:
```typescript
// Use Google Workspace MCP tools
await mcp__google_workspace__search_gmail_messages({
  user_google_email: 'user@example.com',
  query: 'is:unread label:action-required',
  page_size: 100
});
```

**Benefits**:
- Pre-built authentication handling
- Comprehensive error handling
- Rate limiting built-in
- No OAuth implementation needed
- Maintained by community

### 2. Simplify Keep Integration

**Current Approach**: Chrome extension + webhook + unofficial API

**Recommended Approach**: Use Google Tasks API

```typescript
import { google } from 'googleapis';

async function createTaskFromKeep(note: KeepNote): Promise<void> {
  const tasks = google.tasks({ version: 'v1', auth });

  await tasks.tasks.insert({
    tasklist: 'primary',
    requestBody: {
      title: note.title,
      notes: note.content,
      due: note.reminder?.date
    }
  });
}
```

**Benefits**:
- Official API (stable, supported)
- Similar functionality to Keep
- No custom extension needed
- Integrates with Google Calendar

### 3. Event-Driven Architecture

Implement a proper event bus for integration coordination:

```typescript
// Central event bus
import EventEmitter from 'events';

interface IntegrationEvent {
  source: string;
  type: 'task.created' | 'task.updated' | 'task.deleted' | 'email.received';
  data: any;
  timestamp: Date;
}

class IntegrationEventBus extends EventEmitter {
  async publish(event: IntegrationEvent): Promise<void> {
    this.emit(event.type, event);

    // Persist event for audit trail
    await this.persistEvent(event);

    // Send to message queue for distributed processing
    await this.messageQueue.send(event);
  }
}

// Service integration
const bus = new IntegrationEventBus();

// Gmail subscribes to task events
bus.on('task.created', async (event) => {
  if (event.data.source === 'gmail') {
    // Skip to avoid circular updates
    return;
  }

  // Maybe send email notification
  await gmailService.sendNotification(event.data);
});

// Todoist subscribes to task events
bus.on('task.created', async (event) => {
  if (event.data.source === 'todoist') {
    return; // Already in Todoist
  }

  await todoistService.createTask(event.data);
});
```

---

## Testing Recommendations

### 1. Integration Test Gaps

**Documentation** shows example tests (lines 1146-1199) but no actual test files exist.

**Required Test Coverage**:

```typescript
// tests/integration/todoist.test.ts
describe('Todoist Integration', () => {
  beforeEach(async () => {
    // Setup test project in Todoist
    testProject = await api.addProject({ name: 'Test Project' });
  });

  afterEach(async () => {
    // Cleanup
    await api.deleteProject(testProject.id);
  });

  it('should sync task from memory to Todoist', async () => {
    // Add task to memory
    const task = {
      content: 'Test task',
      project: 'Test Project'
    };

    await memoryManager.addTask(task);

    // Run export
    await exportToTodoist();

    // Verify in Todoist
    const tasks = await api.getTasks({ projectId: testProject.id });
    expect(tasks).toHaveLength(1);
    expect(tasks[0].content).toBe('Test task');
  });

  it('should handle rate limiting gracefully', async () => {
    // Create many tasks to trigger rate limit
    const tasks = Array(150).fill(null).map((_, i) => ({
      content: `Task ${i}`
    }));

    // Should not throw, should use backoff
    await expect(exportToTodoist(tasks)).resolves.not.toThrow();
  });

  it('should recover from service unavailable', async () => {
    // Mock 503 response
    jest.spyOn(api, 'addTask')
      .mockRejectedValueOnce({ httpStatusCode: 503 })
      .mockResolvedValueOnce({ id: '123', content: 'Test' });

    // Should retry and succeed
    await expect(exportToTodoist()).resolves.not.toThrow();
  });
});

// tests/integration/gmail.test.ts
describe('Gmail Integration', () => {
  it('should extract action items from email', async () => {
    const email = {
      subject: 'Project deadline',
      body: 'Please complete the Q4 report by Friday'
    };

    const actions = await extractActions(email);

    expect(actions).toHaveLength(1);
    expect(actions[0].title).toContain('Q4 report');
    expect(actions[0].dueDate).toBeDefined();
  });
});
```

### 2. Security Testing

```typescript
// tests/security/webhook-security.test.ts
describe('Webhook Security', () => {
  it('should reject requests with invalid signature', async () => {
    const payload = JSON.stringify({ event: 'test' });
    const invalidSignature = 'invalid';

    const response = await request(app)
      .post('/webhook/telegram')
      .set('X-Signature', invalidSignature)
      .send(payload);

    expect(response.status).toBe(401);
  });

  it('should reject replay attacks', async () => {
    const payload = {
      event: 'task.created',
      timestamp: Date.now() - 600000 // 10 minutes ago
    };

    const response = await request(app)
      .post('/webhook/telegram')
      .send(payload);

    expect(response.status).toBe(401);
  });
});
```

---

## Implementation Priority Matrix

| Task | Impact | Effort | Priority | Timeline |
|------|--------|--------|----------|----------|
| Revoke exposed credentials | üî¥ Critical | Low | P0 | 1 hour |
| Implement credential vault | üî¥ Critical | Medium | P0 | 8-16 hours |
| Remove insecure transport | üî¥ Critical | Low | P0 | 4-8 hours |
| Gmail email processing | üü° High | High | P1 | 24-40 hours |
| Complete Todoist sync | üü° High | Medium | P1 | 16-24 hours |
| Replace Keep with Tasks | üü° High | Medium | P1 | 16-24 hours |
| Implement webhook server | üü° High | Medium | P1 | 16-24 hours |
| Unified error handling | üü¢ Medium | Medium | P2 | 16-24 hours |
| Circuit breaker pattern | üü¢ Medium | Low | P2 | 8-16 hours |
| Rate limiting | üü¢ Medium | Low | P2 | 8-16 hours |
| Chrome bookmarks | üîµ Low | High | P3 | 64-100 hours |
| Telegram bot | üîµ Low | High | P3 | 40-64 hours |
| Monitoring setup | üîµ Low | Medium | P3 | 24-40 hours |

**Estimated Total Effort**: 260-400 hours (6-10 weeks for 1 developer)

---

## Conclusion

The integration documentation demonstrates **strong architectural knowledge** and comprehensive planning. However, the project faces significant **security risks** and **implementation gaps** that must be addressed.

### Strengths
‚úÖ Comprehensive error handling patterns
‚úÖ Correct API usage and compatibility
‚úÖ Well-designed architecture (event bus, state machine)
‚úÖ Detailed data flow diagrams
‚úÖ Security-aware credential management (documented)

### Critical Issues
üî¥ Exposed OAuth credentials in version control
üî¥ Insecure transport mode enabled
üî¥ Missing credential encryption
üî¥ No webhook security implementation
üî¥ Google Keep integration unfeasible (no official API)

### Immediate Next Steps

1. **Security Remediation** (P0 - 1 day)
   - Revoke exposed credentials
   - Implement credential vault
   - Enable HTTPS for OAuth

2. **Core Integration Implementation** (P1 - 4-6 weeks)
   - Complete Gmail integration with MCP
   - Finish Todoist bidirectional sync
   - Replace Keep with Google Tasks
   - Build webhook server

3. **Infrastructure & Testing** (P2 - 2-3 weeks)
   - Implement error handling
   - Add circuit breakers
   - Write integration tests
   - Set up monitoring

4. **Optional Integrations** (P3 - Future)
   - Chrome bookmarks extension
   - Telegram bot
   - Advanced features

**Recommended Approach**: Focus on **security fixes** and **2 core integrations** (Todoist + Gmail) before expanding to other services.
